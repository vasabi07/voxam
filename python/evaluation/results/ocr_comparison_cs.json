{
  "document": "cs",
  "comparisons": {
    "gemini": {
      "model_key": "gemini",
      "model_name": "Gemini 2.0 Flash",
      "provider": "gemini",
      "total_pages": 2,
      "total_chars": 3185,
      "total_latency_ms": 8959,
      "avg_chars_per_page": 1592.5,
      "avg_latency_per_page_ms": 4479.5,
      "total_tokens_input": 3700,
      "total_tokens_output": 897,
      "cost_estimate": 0.0007288000000000002,
      "cost_per_1000_pages": 0.36440000000000006,
      "pages_with_latex": 0,
      "total_latex_count": 0,
      "pages_with_tables": 0,
      "pages_with_code": 1,
      "page_results": [
        {
          "page_num": 1,
          "model_name": "Gemini 2.0 Flash",
          "text": "Chapter\n6 Searching\n12130CH06\n\nIn this Chapter\n\n>> Introduction\n>> Linear Search\n>> Binary Search\n>> Search by Hashing\n\n\"Even though most people won't be directly\ninvolved with programming, everyone is affected\nby computers, so an educated person should have\na good understanding of how computer hardware,\nsoftware, and networks operate.\"\n\n- Brian Kernighan\n\n6.1 Introduction\n\nWe store many things in our home and find them\nout later as and when required. Sometimes we\nremember the exact location of a required item.\nBut, sometimes we do not remember the exact\nlocation and in that case we need to search for\nthe required item. A computer also stores lots of\ndata to be retrieved later as and when demanded\nby a user or a program.\n\nSearching means locating a particular\nelement in a collection of elements. Search result\ndetermines whether that particular element is\npresent in the collection or not. If it is present,\nwe can also find out the position of that element\nin the given collection. Searching is an important\ntechnique in computer science. In order to design\nalgorithms, programmers need to understand the\ndifferent ways in which a collection of data can be\nsearched for retrieval.\n\nReprint 2025-26\n",
          "char_count": 1210,
          "latency_ms": 4168,
          "tokens_input": 1850,
          "tokens_output": 277,
          "error": null,
          "has_latex": false,
          "latex_count": 0,
          "has_tables": false,
          "table_count": 0,
          "has_code_blocks": false
        },
        {
          "page_num": 2,
          "model_name": "Gemini 2.0 Flash",
          "text": "```\nActivity 6.1\nConsider a list of 15\nelements:\nL=[2,3,9,7,-\n6,11,12,17,45,23,29,\n31,-37,41,43].\nDetermine the number\nof comparisons\nlinear search\nmakes to search\nfor key = 12.\n6.2 LINEAR SEARCH\nLinear search is the most fundamental and the simplest\nsearch method. It is an exhaustive searching technique\nwhere every element of a given list is compared with\nthe item to be searched (usually referred to as 'key').\nSo, each element in the list is compared one by one\nwith the key. This process continues until an element\nmatching the key is found and we declare that the\nsearch is successful. If no element matches the key and\nwe have traversed the entire list, we declare the search\nis unsuccessful i.e., the key is not present in the list.\nThis item by item comparison is done in the order, in\nwhich the elements are present in the list, beginning at\nthe first element of the list and moving towards the last.\nThus, it is also called sequential search or serial search.\nThis technique is useful for collection of items that are\nsmall in size and are unordered.\nGiven a list numList of n elements and key value K,\nAlgorithm 6.1 uses a linear search algorithm to find the\nposition of the key K in numList.\n\nAlgorithm 6.1 : Linear Search\nLinearSearch(numList, key, n)\nStep 1: SET index = 0\nStep 2: WHILE index < n, REPEAT Step 3\nStep 3: IF numlist[index]= key THEN\nPRINT \"Element found at position\", index+1\nSTOP\nELSE\nindex = index+1\nStep 4: PRINT \"Search unsuccessful\"\n\nExample 6.1 Assume that the numList has seven elements\n[8, -4, 7, 17, 0, 2, 19] so, n = 7. We need to search for the key,\nsay 17 in numList. Table 6.1 shows the elements in the given\nlist along with their index values.\nTable 6.1 Elements in numList alongwith their index value\nIndex in numList 0\n1\n2\n3\n4\n5\n6\nValue\n8\n-4\n7\n17\n0\n2\n19\n82\nChpater-6.indd 82\nThe step-by-step process of linear search using\nAlgorithm 6.1. is given in Table 6.2.\nReprint 2025-26\nCOMPUTER SCIENCE CLASS XII\n18-Jun-21 2:32:08 PM\n```",
          "char_count": 1975,
          "latency_ms": 4791,
          "tokens_input": 1850,
          "tokens_output": 620,
          "error": null,
          "has_latex": false,
          "latex_count": 0,
          "has_tables": false,
          "table_count": 0,
          "has_code_blocks": true
        }
      ]
    },
    "olmocr2": {
      "model_key": "olmocr2",
      "model_name": "olmOCR-2 (7B)",
      "provider": "deepinfra",
      "total_pages": 2,
      "total_chars": 3163,
      "total_latency_ms": 14627,
      "avg_chars_per_page": 1581.5,
      "avg_latency_per_page_ms": 7313.5,
      "total_tokens_input": 6058,
      "total_tokens_output": 808,
      "cost_estimate": 0.00069874,
      "cost_per_1000_pages": 0.34937,
      "pages_with_latex": 0,
      "total_latex_count": 0,
      "pages_with_tables": 0,
      "pages_with_code": 0,
      "page_results": [
        {
          "page_num": 1,
          "model_name": "olmOCR-2 (7B)",
          "text": "Chapter 6 Searching\n\nIn this Chapter\n\u00bb Introduction\n\u00bb Linear Search\n\u00bb Binary Search\n\u00bb Search by Hashing\n\n\"Even though most people won't be directly involved with programming, everyone is affected by computers, so an educated person should have a good understanding of how computer hardware, software, and networks operate.\"\n\u2014 Brian Kernighan\n\n6.1 Introduction\nWe store many things in our home and find them out later as and when required. Sometimes we remember the exact location of a required item. But, sometimes we do not remember the exact location and in that case we need to search for the required item. A computer also stores lots of data to be retrieved later as and when demanded by a user or a program.\n\nSearching means locating a particular element in a collection of elements. Search result determines whether that particular element is present in the collection or not. If it is present, we can also find out the position of that element in the given collection. Searching is an important technique in computer science. In order to design algorithms, programmers need to understand the different ways in which a collection of data can be searched for retrieval.",
          "char_count": 1175,
          "latency_ms": 8961,
          "tokens_input": 3029,
          "tokens_output": 231,
          "error": null,
          "has_latex": false,
          "latex_count": 0,
          "has_tables": false,
          "table_count": 0,
          "has_code_blocks": false
        },
        {
          "page_num": 2,
          "model_name": "olmOCR-2 (7B)",
          "text": "6.2 LINEAR SEARCH\n\nLinear search is the most fundamental and the simplest search method. It is an exhaustive searching technique where every element of a given list is compared with the item to be searched (usually referred to as \u2018key\u2019). So, each element in the list is compared one by one with the key. This process continues until an element matching the key is found and we declare that the search is successful. If no element matches the key and we have traversed the entire list, we declare the search is unsuccessful i.e., the key is not present in the list. This item by item comparison is done in the order, in which the elements are present in the list, beginning at the first element of the list and moving towards the last. Thus, it is also called sequential search or serial search. This technique is useful for collection of items that are small in size and are unordered.\n\nGiven a list numList of n elements and key value K, Algorithm 6.1 uses a linear search algorithm to find the position of the key K in numList.\n\nAlgorithm 6.1 : Linear Search\nLinearSearch(numList, key, n)\nStep 1: SET index = 0\nStep 2: WHILE index < n, REPEAT Step 3\nStep 3: IF numlist[index]= key THEN\n    PRINT \u201cElement found at position\u201d, index+1\n    STOP\n    ELSE\n        index = index+1\nStep 4: PRINT \u201cSearch unsuccessful\u201d\n\nExample 6.1 Assume that the numList has seven elements [8, -4, 7, 17, 0, 2, 19] so, n = 7. We need to search for the key, say 17 in numList. Table 6.1 shows the elements in the given list along with their index values.\n\nTable 6.1 Elements in numList alongwith their index value\n\n<table>\n  <tr>\n    <th>Index in numList</th>\n    <th>0</th>\n    <th>1</th>\n    <th>2</th>\n    <th>3</th>\n    <th>4</th>\n    <th>5</th>\n    <th>6</th>\n  </tr>\n  <tr>\n    <th>Value</th>\n    <td>8</td>\n    <td>-4</td>\n    <td>7</td>\n    <td>17</td>\n    <td>0</td>\n    <td>2</td>\n    <td>19</td>\n  </tr>\n</table>\n\nThe step-by-step process of linear search using Algorithm 6.1. is given in Table 6.2.",
          "char_count": 1988,
          "latency_ms": 5666,
          "tokens_input": 3029,
          "tokens_output": 577,
          "error": null,
          "has_latex": false,
          "latex_count": 0,
          "has_tables": false,
          "table_count": 0,
          "has_code_blocks": false
        }
      ]
    },
    "gemma-12b": {
      "model_key": "gemma-12b",
      "model_name": "Gemma-3-12B-IT",
      "provider": "deepinfra",
      "total_pages": 2,
      "total_chars": 2706,
      "total_latency_ms": 28143,
      "avg_chars_per_page": 1353.0,
      "avg_latency_per_page_ms": 14071.5,
      "total_tokens_input": 730,
      "total_tokens_output": 784,
      "cost_estimate": 0.00013112,
      "cost_per_1000_pages": 0.06556000000000001,
      "pages_with_latex": 0,
      "total_latex_count": 0,
      "pages_with_tables": 1,
      "pages_with_code": 0,
      "page_results": [
        {
          "page_num": 1,
          "model_name": "Gemma-3-12B-IT",
          "text": "Chapter\n\n6 Searching\n\n[QR Code]\n\n\"Even though most people won\u2019t be directly involved with programming, everyone is affected by a good understanding of how computer hardware, software, and networks operate.\" \n\n- Brian Kernighan\n\n**In this Chapter**\n\n*   Introduction\n*   Linear Search\n*   Binary Search\n*   Search by Hashing\n\n6.1 INTRODUCTION\n\nWe store many things in our home and find them out later as and when required. Sometimes we remember the exact location of a required item. But, sometimes we do not remember the exact location and in that case we need to search for the required item. A computer also stores lots of data to be retrieved later as and when demanded by a user or a program.\n\nSearching a particular technique in order to understand the different ways in which a collection of data can be searched for retrieval.\n\nReprint 2025-26 18-Jun-21",
          "char_count": 860,
          "latency_ms": 7744,
          "tokens_input": 365,
          "tokens_output": 199,
          "error": null,
          "has_latex": false,
          "latex_count": 0,
          "has_tables": false,
          "table_count": 0,
          "has_code_blocks": false
        },
        {
          "page_num": 2,
          "model_name": "Gemma-3-12B-IT",
          "text": "## 6.2 Linear Search\n\nLinear search is the most fundamental and the simplest search method. It is an exhaustive searching technique where every element of a given list is compared with the item to be searched (usually referred to as 'key').\n\nSo, each element in the list is compared one by one with the key. This process continues until an element matching the key is found or we declare that the search is unsuccessful i.e., the key is not present in the list.\n\nThis item by item comparison is done in the order, in which the elements are present in the list, beginning at the first element of the list and moving towards the last. Thus, it is also called sequential search or serial search.\n\nLinear search(numList, key, n)\n\nGiven a list numList of n elements and key value K, Algorithm 6.1 uses a linear search algorithm to find the position of the key K in numList.\n\n**Algorithm 6.1 : Linear Search**\n\nPRINT \"List index = 0\"\nStep 1: SET index = 0\nStep 2: WHILE index < n, REPEAT Step 3\nStep 3: IF numList[index] = key THEN\n   PRINT \"Element found at position\", index+1\n   STOP\nELSE\n   index = index+1\nStep 4: PRINT \"Search unsuccessful\"\n\n**Example 6.1** Assume that the numList has seven elements [8, -4, 7, 17, 0, 2, 19] to search for the key, say 17 in numList. Table 6.1 shows the index value list along with their index values.\n\n**Table 6.1** Index in numList\n\n| Index | numList |\n|---|---|\n| 0 | 8 |\n| 1 | -4 |\n| 2 | 7 |\n| 3 | 17 |\n| 4 | 0 |\n| 5 | 2 |\n| 6 | 19 |\n\nThe step-by-step process of linear search using Algorithm 6.1 is given in Table 6.2.\n\n[Table with index values 6.1, 11, 12, 17, 45, 23, 29, 31, -37, 41, 43]\nDetermine the number of comparisons linear search makes to search for key = 12.\n\n[Diagram illustrating the linear search process.]\n\n82\n\nCOMPUTER SCIENCE - Class XII\nChapter-6.indd 82\nReprint 2025-26 18-Jun-21:32:08 PM",
          "char_count": 1846,
          "latency_ms": 20399,
          "tokens_input": 365,
          "tokens_output": 585,
          "error": null,
          "has_latex": false,
          "latex_count": 0,
          "has_tables": true,
          "table_count": 4,
          "has_code_blocks": false
        }
      ]
    },
    "mistral-small": {
      "model_key": "mistral-small",
      "model_name": "Mistral-Small-3.1-24B",
      "provider": "deepinfra",
      "total_pages": 2,
      "total_chars": 3560,
      "total_latency_ms": 29128,
      "avg_chars_per_page": 1780.0,
      "avg_latency_per_page_ms": 14564.0,
      "total_tokens_input": 5052,
      "total_tokens_output": 991,
      "cost_estimate": 0.0005771,
      "cost_per_1000_pages": 0.28855,
      "pages_with_latex": 0,
      "total_latex_count": 0,
      "pages_with_tables": 1,
      "pages_with_code": 2,
      "page_results": [
        {
          "page_num": 1,
          "model_name": "Mistral-Small-3.1-24B",
          "text": "```markdown\n# Chapter 6 Searching\n\n[QR code with the text \"12130CH06\" below it]\n\n**In this Chapter**\n- Introduction\n- Linear Search\n- Binary Search\n- Search by Hashing\n\n> \"Even though most people won't be directly involved with programming, everyone is affected by computers, so an educated person should have a good understanding of how computer hardware, software, and networks operate.\"\n> \u2014 Brian Kernighan\n\n## 6.1 Introduction\n\nWe store many things in our home and find them out later as and when required. Sometimes we remember the exact location of a required item. But, sometimes we do not remember the exact location and in that case we need to search for the required item. A computer also stores lots of data to be retrieved later as and when demanded by a user or a program.\n\nSearching means locating a particular element in a collection of elements. Search result determines whether that particular element is present in the collection or not. If it is present, we can also find out the position of that element in the given collection. Searching is an important technique in computer science. In order to design algorithms, programmers need to understand the different ways in which a collection of data can be searched for retrieval.\n\n*Reprint 2025-26*\n\n*Chpater-6.indd 81*\n\n*18-Jun-21 2:32:08 PM*\n```",
          "char_count": 1315,
          "latency_ms": 9532,
          "tokens_input": 2526,
          "tokens_output": 307,
          "error": null,
          "has_latex": false,
          "latex_count": 0,
          "has_tables": false,
          "table_count": 0,
          "has_code_blocks": true
        },
        {
          "page_num": 2,
          "model_name": "Mistral-Small-3.1-24B",
          "text": "```markdown\n# 6.2 Linear Search\n\nLinear search is the most fundamental and the simplest search method. It is an exhaustive searching technique where every element of a given list is compared with the item to be searched (usually referred to as 'key'). So, each element in the list is compared one by one with the key. This process continues until an element matching the key is found and we declare that the search is successful. If no element matches the key and we have traversed the entire list, we declare the search is unsuccessful i.e., the key is not present in the list. This item by item comparison is done in the order, in which the elements are present in the list, beginning at the first element of the list and moving towards the last. Thus, it is also called sequential search or serial search. This technique is useful for collection of items that are small in size and are unordered.\n\nGiven a list `numList` of `n` elements and key value `K`, Algorithm 6.1 uses a linear search algorithm to find the position of the key `K` in `numList`.\n\n## Algorithm 6.1: Linear Search\n\n**LinearSearch(numList, key, n)**\n\n**Step 1:** SET index = 0\n\n**Step 2:** WHILE index < n, REPEAT Step 3\n\n**Step 3:** IF numlist[index] = key THEN\nPRINT \"Element found at position\", index+1\nSTOP\nELSE\nindex = index+1\n\n**Step 4:** PRINT \"Search unsuccessful\"\n\n### Activity 6.1\n\nConsider a list of 15 elements:\nL = [2, 3, 9, 7, 6, 11, 12, 17, 45, 23, 29, 31, -37, 41, 43].\nDetermine the number of comparisons linear search makes to search for key = 12.\n\n[Image of a person working on a laptop]\n\n### Example 6.1\n\nAssume that the `numList` has seven elements [8, -4, 7, 17, 0, 2, 19] so, n = 7. We need to search for the key, say 17 in `numList`. Table 6.1 shows the elements in the given list along with their index values.\n\n#### Table 6.1 Elements in `numList` alongwith their index value\n\n| Index in `numList` | 0 | 1 | 2 | 3 | 4 | 5 | 6 |\n|--------------------|---|---|---|---|---|---|---|\n| Value              | 8 | -4| 7 | 17| 0 | 2 | 19|\n\nThe step-by-step process of linear search using Algorithm 6.1 is given in Table 6.2.\n\n[Image of a book cover with the text \"Computer Science - Class XII\"]\n\nReprint 2025-26\n\nChpater-6.indd 82\n\n18-Jun-21 2:32:08 PM\n```",
          "char_count": 2245,
          "latency_ms": 19596,
          "tokens_input": 2526,
          "tokens_output": 684,
          "error": null,
          "has_latex": false,
          "latex_count": 0,
          "has_tables": true,
          "table_count": 1,
          "has_code_blocks": true
        }
      ]
    },
    "deepseek-ocr": {
      "model_key": "deepseek-ocr",
      "model_name": "DeepSeek-VL2-Small",
      "provider": "deepinfra",
      "total_pages": 2,
      "total_chars": 3955,
      "total_latency_ms": 7901,
      "avg_chars_per_page": 1977.5,
      "avg_latency_per_page_ms": 3950.5,
      "total_tokens_input": 2028,
      "total_tokens_output": 971,
      "cost_estimate": 0.00015794,
      "cost_per_1000_pages": 0.07897,
      "pages_with_latex": 1,
      "total_latex_count": 4,
      "pages_with_tables": 1,
      "pages_with_code": 1,
      "page_results": [
        {
          "page_num": 1,
          "model_name": "DeepSeek-OCR",
          "text": " The text after listing the requirements. \n\n> Introduction\n> Linear Search\n> Binary Search\n> Search by Hashing\n\n> Reading the text and extracting the necessary information, you find that the document requires an in-place page layout. Here is how you can proceed:\n\n---\n\n## 6 Searching\n\nEven though most people won\u2019t be directly involved with programming, everyone is affected by computers, so an educated person should have a good understanding of how computer hardware, software, and networks operate.\u201d\nBrain Kernighan\n\n---\n\n## 6.1 INTRODUCTION\n\nWe store many things in our home and find them out later as and when required. Sometimes we remember the exact location of a required item. But, sometimes we do not remember the exact location and in that case we need to search for the required item. A computer also stores lots of data to be retrieved later as and when demanded by a user or a program.\n\nSearching means locating a particular element in a collection of elements. Search result determines whether that particular element is present in the collection or not. If it is present, we can also find out the position of that element in the given collection. Searching is an important technique in computer science. In order to design algorithms, programmers need to understand the different ways in which a collection of data can be searched for retrieval.\n\n---\n\n| Section | Topic |\n|---------|-------|\n| Chapter | 6    |\n| 6       | Searching |\n\nReprint 2025-26",
          "char_count": 1467,
          "latency_ms": 3151,
          "tokens_input": 1014,
          "tokens_output": 300,
          "error": null,
          "has_latex": false,
          "latex_count": 0,
          "has_tables": true,
          "table_count": 2,
          "has_code_blocks": false
        },
        {
          "page_num": 2,
          "model_name": "DeepSeek-OCR",
          "text": "6. Eating space\n\nLinear search is the most fundamental and the simplest search method. It is an exhaustive searching technique where every element of a given list is compared with the item to be searched (usually referred to as 'key'). So, each element in the list is compared one by one with the key. This process continues until an element matching the key is found and we declare that the search is successful. If no element matches the key and we have traversed the entire list, we declare the search is unsuccessful, i.e., the key is not present in the list. This item by item comparison is done in the order, in which the elements are present in the list, beginning at the first element of the list and moving towards the last. Thus, it is also called sequential search or serial search. This technique is usual for collections of items that are small in size and are unordered.\n\nGiven a list numList of n elements and key value K, Algorithm 6.1 uses a linear search algorithm to find the position of the key K in numList.\n\nAlgorithm 6.1: Linear Search\nLinearSearch(numList, key, n)\n\nStep 1: SET index = 0\nStep 2: WHILE index < n, REPEAT Step 3\n\n$Index = \\text{key}\"\nStep 3: IF numList[index] = key THEN\n    PRINT \"Element found at position\", index + 1\n$End IF$\nStep 4: PRINT \"Search unsuccessful\"\n\nExample 6.1: Assume that the numList has seven elements [8, -4, 7, 17, 0, 2, 19], so, `n = 7`. We need to search for the key, and the result is 7 in numList. Step 5 shows the elements in the given list along with their index values.\n\n$Index = \\text{numList['10']}: \\text{Element found at index 7}$\nList Value: [8, -4, 7, 17, 6, 2, 19]\nThe step-by-step process of linear search using Algorithm 6.1 is given in Table 6.1.\n\nArticle Summary:\nArticle Title: Linear Search\n\nGender Chart\nNation 1: ARGYLES\nNation 2: ADANIEL\n\nAuthor: KARLOV\nPublish Date: 2/12/2023\n\nChapter-6.1: Linear Search\n\nAlgorithm 6.1 in Python,\n```\nN = 7\nPRINT 'Element found at index', i\nELSE\n    index = numList[i]\nEND IF\nBreak\nELSE\n    index += 1\nEND IF\n```\n\nArticle Source: https://titus.dumpl.org/en/statements\nAuthor: Noemi Gillam, version 7.1 maximum for tidy objects, 2020-02-17\nGrammatical Requirements: Maintain the original formatting as closely as possible.\nInformation Security Requirements: Professional\nDescription: A collection of university-level classes covering linear search algorithms for sequential data.The class is \\(3\\) of \\(3\\) from Alg C6.2 download.\nAuthor: Curt Cox\nUpdated: June 12, 2023",
          "char_count": 2488,
          "latency_ms": 4750,
          "tokens_input": 1014,
          "tokens_output": 671,
          "error": null,
          "has_latex": true,
          "latex_count": 4,
          "has_tables": false,
          "table_count": 0,
          "has_code_blocks": true
        }
      ]
    }
  }
}